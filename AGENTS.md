# Assets

## Engine Assets
- The engine's default assets are located in the **`node_modules/genesys.js/assets`** directory.
- To reference these assets in your code, replace the **`node_modules/genesys.js`** prefix with **`@engine`** in the asset path.

  **Example:**  
  If an asset is located at:  
  `node_modules/genesys.js/assets/models/SM_Monkey.glb`  
  Then the corresponding URL should be:  
  `@engine/assets/models/SM_Monkey.glb`


## Project Assets
- The project's assets are located in the **`/assets`** directory.
- To reference these assets in your code, use the **fully qualified path** with **`@project`** prefix.

  **Example:**  
  If an asset is located at:  
  `/assets/models/tiger.glb`  
  Then the corresponding URL should be:  
  `@project/assets/models/tiger.glb`

  **Important:** Always use the complete path with `@project/assets/` prefix rather than relative paths. This ensures compatibility with publishing tools and build processes. You should **never** construct a project path programmatically.

## Resolve Asset Paths
- Using asset paths containing `@engine` or `@project` in raw html will not work out of the box as the browser doesn't know how to resolve them.
  The solution is to resolve them using **`ENGINE.resolveAssetPathsInText`** first.
  Example:
  ```
  const htmlString = '...<img src="@engine/assets/textures/Checkerboard.png">...'
  const resolvedHtml = await ENGINE.resolveAssetPathsInText(htmlString);
  // then use resolvedHtml as normal
  ```

## Prefabs
- When referencing classes in prefab, use the appropriate prefix.
  Engine classes **must** be referenced as `ENGINE.{class name}`, example: `ENGINE.Actor`, `ENGINE.SceneComponent`.
  Custom game classes **must** be referenced as `GAME.{class name}`, example: `GAME.MyCustomActor`, `GAME.MyCustomComponent`.

---

# Coding Rules

**CRITICAL**: Never edit `auto-imports.ts` - This file is automatically generated by the build pipeline to register all @ENGINE.GameClass() decorated classes. Any manual changes will be overwritten and may break the build system. Classes with proper @ENGINE.GameClass() decorators are automatically discovered and imported.

## General Guidelines
- Before implementing, take a hard look of the engine and figure out what can be used to implement the user's requirement. **Do not** reinvent wheels. When using the search tool, expand the search parameters with similar keywords.
- Work **WITH** the engine architecture, **NOT** against it. 
- Try to find and use appropriate art assets as needed if the user does not specify. Check both engine and project assets for something that fits the feature.
- You **should avoid** writing **monolithic code** — do not place all logic, definitions, and configurations into a single file.  
  Instead, structure your code into modular, reusable, and maintainable components.
- Custom actor and component classes **must not** be registered as **`EngineClass`**, use **`GameClass`** instead.
- **Do not** create documentation or test/example code unless specifically asked to.
- Be **very brief** on the summary when the implementation is completed.

## UI
- Any HTML UI you create **MUST NOT** be added to the document root directly. Add them to the game UI container, which can be accessed through `world.gameContainer`.

## Testing Constraints
- You may **only** use `npm run build` to verify code compilation.
- You **must** use `npm run lint` to detect and auto-fix linting issues.
- Do **not** run `npm run test`, `npm run dev`, or `npm run start` — these commands are **not supported**.
- All testing is the responsibility of the user.  
  You are encouraged to:
  - Recommend suitable testing approaches.
  - Collaborate with the user to evaluate test results.


## Prompt Handling & Clarification

Before implementing any user request, you **must** interpret the prompt, identify ambiguities, and either:
- State clear assumptions **before** coding, or
- Ask the user targeted clarification questions.

### Required Steps
1. **Understand intent** — Restate what the user is asking in your own words.
2. **Identify ambiguities** — Look for vague or overloaded terms.
3. **Clarify or assume** —
   - If unclear, ask specific, short questions to confirm meaning.
   - If the user cannot clarify, proceed with explicit, written assumptions.
4. **Confirm scope** — Specify what systems, assets, or files you will change.

This process **prevents incorrect implementations** when user wording is incomplete or ambiguous.
